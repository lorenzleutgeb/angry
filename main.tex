\section{Complex Predicates~vs.~Complex Objects}
\label{sec:main}

In this section we present how a specific class of occurences of higher order predicates can be translated to first order by introducing more complex terms.

For example, consider the following rule taken from the tactics of \ah:

% https://github.com/DeMaCS-UNICAL/Angry-HEX/blob/4ea72273518dfde6240ece9dadea927fd1b79c3c/dlv/tactic.dlv#L133

$$ canPush(o_a,o_b) :- \&canPush[objects,hills](o_a,o_b). \label{main:rule-1} $$

Intuitively, $canPush(o_a, o_b)$ should be true if the object $o_a$ can push the object $o_b$.
To establish the truth of $canPush(o_a, o_b)$ spatial information, like minimum distance and geometric range of the objects, is required; this is obtained by outsourcing the computation to an external source, by means of the external predicate $\&canPush$.
The required knowledge is given as input to $\&canPush$ by using the predicates $objects$ and $hills$: indeed, $\&canPush$ is a \emph{higher-order predicate}.

A useful observation is that the predicates $objects$ and $hills$ both represent sets: $objects$ characterizes the collection of objects that are present in the current level, while $hills$ encodes the morphological structure of the ground on the current level.
These collections represent a form of knowledge that the agent gains before the reasoning phase.
Indeed, in \ah the objects and the information about the world scene are first acquired by the \textbf{Vision} component, as explained in Section~\ref{sec:agent_base}; only after this phase, the \textbf{Planning} component is invoked and the reasoning process takes place.
Thus, for the evaluation of the answer sets wrt.~$canPush$, the elements for which $objects$ and $hills$ do not vary: they are encoded as facts, in the set of assertions \(\mathcal{S}\) added to the program \(\mathcal{P}_{AI}\).

Once understood that $objects$ and $hills$ are representations of sets, we may pose the following question: Would it be possible to replace these predicates with sets?
That is, is there a way to have two sets $O$ and $H$, respectively the sets of objects and hills, in place of  $objects$ and $hills$ in the call to $\&canPush$?

The ASP system underlying \ah does not provide support for complex data structures as objects --- thus, sets as objects are not allowed ---, but only symbolic constants, strings and natural numbers.
By lifting such a restriction, we may be able to translate the rule~\eqref{main:rule-1}, containing a higher-order predicate, into one where only first-order predicates appear, such as:

$$ canPush(o_a,o_b) :- objects(O), hills(H), \&canPush[O,H](o_a,o_b). \label{main:rule-2} $$

% Note that $objects$ and $hills$ are predicates, and consequently $\&canPush$ is a higher order predicate. We observe that $objects$ and $hills$ characterize the set of objects present in the current level of the game and the structure of the ground in the virtual environment respectively.

% In \ah the reasoning process is only invoked after recognizing all objects in the game environment, so for evaluation answer sets wrt.~$canPush$, the objects for which $objects$ and $hills$ hold do not change. They are facts.

% Since $objects$ and $hills$ characterize a set, we may substitute them for $O$ and $H$, the set of objects and the set of hills respectively.

% Note that the ASP system that \ah relies on does not support data structures like sets as objects, but only symbolic constants, strings and positive integers.

% By lifting this restriction, we may translate the rule into first order:

% $$ canPush(o_a,o_b) :- objects(O), hills(H), \&canPush[O,H](o_a,o_b). $$

Now, the predicates $objects$ and $hills$ are unary predicates with a different role: their interpretation will only contain one complex object, a set.
Applying this kind of translation to all the rules employing higher-order predicates yields a program where only first-order predicates appear.

% Here, the role of the predicates $objects$ and $hills$ is a different one. Their interpretation only contains one complex object, a set.

% Applying this translation to all rules that make use of higher order predicates yields a program in first order.

\subsection{Translation}

The ASP system \al allows to insert arbitrary Java objects in place of terms.

In the first stage of the translation, we replace the two sets $objects$ and $hills$, which were previously encoded as predicates, by a Java class called \texttt{ASPWorld}. Instances of this class represent a snapshot of the world, as retrieved by the agent from the game world.
The class contains two \texttt{Collection}s, one containing Angry Birds objects (of type \texttt{ABObject}) and the other containing polygonal shapes, in place of $hills$.

Next, the ``interpretation'' of the external predicate $\&canPush$ --- that is, how it operates on its input to return the pushable objects ---  is specified as a \texttt{@Predicate} instance with type signature
\begin{center}
    \texttt{public Set<List<ConstantTerm>> canPush(ASPWorld aspWorld)}
\end{center}
which indicates that the predicate returns a list of constant terms (of the form \((A,B)\)), that represent the fact that \(A\) can push \(B\), after being hit.

Then, the clause containing the higher-order predicate in~\eqref{main:rule-1} is replaced by the clause

$$ canPush(A,B) :- world(W), \&canPush[W](A,B). \label{main:rule-3} $$

Here, $\&canPush$ is no longer a higher-order predicate: indeed, it receives a ground atom $W$ as input --- which corresponds to a \texttt{ASPWorld} instance --- and returns a list of candidates $(A,B)$ in which the item $A$ can effectively push the item $B$.

%The ASP system \al allows for arbitrary Java objects in place for terms, so a custom class \texttt{ABObjects %implements Set} as well as a list of objects (\texttt{List<ABObject>}) may map to $O$.

% How did we come up with the translation? Discovery of the translation.
% End to end example of translation for a predicate in \ah